---
title: "1445149 and 1430275"
author: "Marc Labe and Shane Serebro"
date: "19 August 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<h3> Introduction </h3>

Firms that experience large negative price shocks are often deemed to be bad investments in the short run owing to investor sentiment and increased volatility in the period after such price shock. However, this may not necessarily be the case as seen in Bremer and Sweeney (1991). Moreover, shares that experience positive price shocks are often considered good investments as many believe this trend will continue for the foreseeable future. In this study, an assessment is carried out to determine whether these firms experience share price reversals and therefore can be traded opportunistically and profitably. 

Furthermore, this study will add to the existing literature with regards to whether the EMH holds in the Johannesburg Stock Exchange (JSE) or does the overreaction hypothesis postulated by De Bondt and Thaler (1985) serve as a better explanation of share price movements. If the EMH does indeed hold true on the JSE, abnormal profits cannot be obtained from trading on significant price movements whereas these profits are obtainable if evidence of the overreaction hypothesis can be found on the JSE. In essence, this paper sets out to reveal whether shares that experience a sudden and significant change in price undergo a reversal in the short-term. Furthermore, it aims to determine whether investing in a company that experiences a large share price movement is a profitable investment strategy for the active trader.


<h3> Methodology </h3>

<h5> Step 1: Importing Packages </h5>

First we import the libraries. The 'googledrive' package allows us to fetch documents directly from Google Drive. This is where we have stored our data. The second package 'readxl' allows us to firstly import and secondly read Microsoft Excel files. This is important as our original data came from an excel spreadsheet.

```{r, message=FALSE, warning=FALSE}
library(googledrive)
library(readxl)
```

<h5> Step 2: Data Claning and Manipulation </h5>

As a part of the Google Drive package, drive_download finds and downloads a file on Google Drive based on an unique identifier (id) into the working directory. If the file already exists, this cfunction is ignored.
Using read_excel from the readxl package, the data is imported into the PriceData dataframe.

```{r, message=FALSE, warning=FALSE}
id <-  "1SGigXMnzubpP15Y1W18GqnlVQFiv95jN"
try(drive_download(as_id(id), overwrite = FALSE), silent = TRUE)
PriceData <- read_excel("Price-Volume-MarketCap.xlsx", 
                        sheet = "Price (D)") 
```

We now declare 2 functions that deals with basic data cleaning. 
NaFunction creates a data frame that consists of booleans of whether each variable in the PriceData dataframe contains only NA or 0 with false meaning that the column contains only NA or 0 and vice versa. 

colClean1's purpose is to remove the "SJ Equity" from the share names in the dataframe. 


```{r, message=FALSE, warning=FALSE}

NaFunction <-  function(column){
  !all(is.na(column) | column == 0)
}


colClean1 <- function(x){
  gsub(" SJ Equity", "", names(x), fixed = TRUE)
}

```

exclP stores the result of running the NaFunction on PriceData. Since the NaFunction computes columns containing only NA or 0 to false, we subset PriceData where exclP is true.

To ensure correct interpretation, we coerce the date column to the date data type. 

Finally, we run colClean1 to remove "SJ Equity" from all the variable names.


```{r}
exclP <-  sapply(PriceData, NaFunction)
PriceData <-  PriceData[exclP]
PriceData$Date <-  as.Date(PriceData$Date)
names(PriceData) <- colClean1(PriceData)
```

<h5> Step 3: Calculating Maximum Drawdowns and Minimum Drawups </h5>

<h6> Settings </h6>

This block sets parameters for the following functions

```{r}

lookback <- 5 
window <- 5
triggerDD <- -0.15
triggerDU <- 0.15
```

```{r}

maxDD <-  function(column, lb){
  dd <- vector(mode = "double", length = (length(column) - lb))
  for (i in (lb+1):length(column)){
    if(is.na(max(column[(i-lb):i]))){
      dd[i] <- 0
    } else{
      dd[i] <- (column[i] - max(column[(i-lb):i], na.rm = T))/max(column[(i-lb):i], na.rm = T)
    }
  }
  return(dd)
}

minDU <-  function(column, lb){
  du <- vector(mode = "double", length = (length(column) - lb))
  for (i in (lb+1):length(column)){
    if(is.na(min(column[(i-lb):i]))){
      du[i] <- 0
    } else{
      du[i] <- (column[i] - min(column[(i-lb):i], na.rm = T))/min(column[(i-lb):i], na.rm = T)
    }
  }
 return(du)
}

```


```{r}
DUdf <-  as.data.frame(sapply(PriceData[-1], minDU, lb = lookback))
DUdf <-  cbind(PriceData$Date, DUdf)
names(DUdf)[names(DUdf) == "PriceData$Date"] <- "Date"


DDdf <-  as.data.frame(sapply(PriceData[-1], maxDD, lb = lookback))
DDdf <-  cbind(PriceData$Date, DDdf)
names(DDdf)[names(DDdf) == "PriceData$Date"] <- "Date"

```


```{r}
DDdf <-  DDdf[-c(1:5), ]
DUdf <-  DUdf[-c(1:5), ]
PriceData <-  PriceData[-c(1:5), ]

```

```{r}
trigIndexDD <- lapply(DDdf[-1], function(i){
  trigDD <- vector(mode = "integer", length = 1)
  l = length(i)
  s = 0
  pos = 1
  while(s <= l){
    x = which(i[(s+1):l] <= triggerDD)[1]+s
    if(is.na(x)){
      break
    } else{
      trigDD[pos] = x
    }
    s = trigDD[pos] + window
    pos = pos + 1
  }
  return(trigDD)
})

trigIndexDU <- lapply(DUdf[-1], function(i){
  trigDU <- vector(mode = "integer", length = 1)
  l = length(i)
  s = 0
  pos = 1
  while(s <= l){
    x = which(i[(s+1):l] >= triggerDU)[1]+s
    if(is.na(x)){
      break
    } else{
      trigDU[pos] = x
    }
    s = trigDU[pos] + window
    pos = pos + 1
  }
  return(trigDU)
})

```