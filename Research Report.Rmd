---
title: "Opportunity Trading of Short Run Reversals - Evidence from the JSE"
author: "Marc Labe(1445149) and Shane Serebro(1430275)"
output:
  html_document: default
  pdf_document: default
  word_document: default
---

<h3> Introduction </h3>

Firms that experience large negative price shocks are often deemed to be bad investments in the short run owing to investor sentiment and increased volatility in the period after such price shock. However, this may not necessarily be the case as seen in Bremer and Sweeney (1991). Moreover, shares that experience positive price shocks are often considered good investments as many believe this trend will continue for the foreseeable future. In this study, an assessment is carried out to determine whether these firms experience share price reversals and therefore can be traded opportunistically and profitably. 

Furthermore, this study will add to the existing literature with regards to whether the EMH holds in the Johannesburg Stock Exchange (JSE) or does the overreaction hypothesis postulated by De Bondt and Thaler (1985) serve as a better explanation of share price movements. If the EMH does indeed hold true on the JSE, abnormal profits cannot be obtained from trading on significant price movements whereas these profits are obtainable if evidence of the overreaction hypothesis can be found on the JSE. In essence, this paper sets out to reveal whether shares that experience a sudden and significant change in price undergo a reversal in the short-term. Furthermore, it aims to determine whether investing in a company that experiences a large share price movement is a profitable investment strategy for the active trader.


<h3> Methodology </h3>

<h4> Step 1: Importing Packages </h4>

First we import the libraries. The 'googledrive' package allows us to fetch documents directly from Google Drive. This is where we have stored our data. The second package 'readxl' allows us to firstly import and secondly read Microsoft Excel files. This is important as our original data came from an excel spreadsheet. Finally, the 'qrmtools' package provides a range of quantitative finance functions that will be used later on.

```{r, message=FALSE, warning=FALSE}
library(googledrive)
library(readxl)
library(qrmtools)
```

<h4> Step 2: Data Claning and Manipulation </h4>

As a part of the Google Drive package, drive_download finds and downloads a file on Google Drive based on an unique identifier (id) into the working directory. If the file already exists, this cfunction is ignored.
Using read_excel from the readxl package, the data is imported into the PriceData dataframe.

```{r, message=FALSE, warning=FALSE, eval=TRUE}
id <-  "1SGigXMnzubpP15Y1W18GqnlVQFiv95jN"
#try(drive_download(as_id(id), overwrite = FALSE), silent = TRUE)
PriceData <- read_excel("Price-Volume-MarketCap.xlsx", 
                        sheet = "Price (D)") 

knitr::kable(PriceData[1:10, 1:8])
```

We now declare 2 functions that deals with basic data cleaning. 
NaFunction creates a data frame that consists of booleans of whether each variable in the PriceData dataframe contains only NA or 0 with false meaning that the column contains only NA or 0 and vice versa. 

colClean1's purpose is to remove the "SJ Equity" from the share names in the dataframe. 


```{r, message=FALSE, warning=FALSE}

NaFunction <-  function(column){
  !all(is.na(column) | column == 0)
}


colClean1 <- function(x){
  gsub(" SJ Equity", "", names(x), fixed = TRUE)
}

```

exclP stores the result of running the NaFunction on PriceData. Since the NaFunction computes columns containing only NA or 0 to false, we subset PriceData where exclP is true.

To ensure correct interpretation, we coerce the date column to the date data type. 

Finally, we run colClean1 to remove "SJ Equity" from all the variable names.


```{r}
exclP <-  sapply(PriceData, NaFunction)
PriceData <-  PriceData[exclP]
PriceData$Date <-  as.Date(PriceData$Date)
names(PriceData) <- colClean1(PriceData)
```

<h5>Returns</h5>

Returns are calculated for each share.

First we extract the share prices only(no dates) in order to convert the PriceData dataframe to a numeric matrix.

The returns are the then calculated using the "returns" function of the qrmtools package and are then returned as a dataframe. As the returns function ignores the first row, it is inserted manually using a combination of rbind and seq.

```{r}
PriceDataNew <-  PriceData[, -1]

PriceDataNew <-  sapply(PriceDataNew, function(x){
  as.numeric(x)
})

returnsDf <- as.data.frame(returns(PriceDataNew, method = "simple"))
returnsDf <-  rbind(seq(from = 0, to = 0, length.out = 448), returnsDf)

knitr::kable(returnsDf[(1:10), (1:8)])
```

<h4> Step 3: Calculating Maximum Drawdowns and Minimum Drawups </h4>

<h5> Settings </h5>

This block sets parameters for the following functions

```{r}

lookback <- 5 
window <- 5
triggerDD <- -0.15
triggerDU <- 0.15
```


<h5> Function Declarations </h5>

We now declare the functions that will calculate the maximum drawdown and minimum drawups:


1) Maximum drawdowns are calculated according to the following formula: $$ MaxDD = (P_{t} -  max(P_{t}, P_{t-lb} ))/ max(P_{t}, P_{t-lb}) $$ with $$ P_{t} $$ = the share price at time t and $$lb$$ = the lookback period (defined earlier as 5 days)

We create a for loop which calculates the drawdowns according to the formula, with the result being written to a new vector that will be a component of the new data frame. However, if the calculations result in a NA, it is replaced with a 0 in the new vector


```{r}

maxDD <-  function(column, lb){
  dd <- vector(mode = "double", length = (length(column) - lb))
  for (i in (lb+1):length(column)){
    if(is.na(max(column[(i-lb):i]))){
      dd[i] <- 0
    } else{
      dd[i] <- (column[i] - max(column[(i-lb):i], na.rm = T))/max(column[(i-lb):i], na.rm = T)
    }
  }
  return(dd)
}

```

2) Similarly with minimum drawdowns, an identical function is created, however with the following formula:

$$ MaxDD = (P_{t} -  min(P_{t}, P_{t-lb} ))/ min(P_{t}, P_{t-lb})$$

```{r}
minDU <-  function(column, lb){
  du <- vector(mode = "double", length = (length(column) - lb))
  for (i in (lb+1):length(column)){
    if(is.na(min(column[(i-lb):i]))){
      du[i] <- 0
    } else{
      du[i] <- (column[i] - min(column[(i-lb):i], na.rm = T))/min(column[(i-lb):i], na.rm = T)
    }
  }
 return(du)
}

```

Running the function (with lb set to lookback as defined above), we created a new dataframe that stores the maximum drawdowns (DDdf) and the minimum drawups (DUdf).

```{r}

DDdf <-  as.data.frame(sapply(PriceData[-1], maxDD, lb = lookback))
DUdf <-  as.data.frame(sapply(PriceData[-1], minDU, lb = lookback))

knitr::kable(DDdf[(1:10), (1:8)])
```

<h5> Cleaning and formatting </h5>



```{r}
DDdf <-  cbind(PriceData$Date, DDdf)
names(DDdf)[names(DDdf) == "PriceData$Date"] <- "Date"
DUdf <-  cbind(PriceData$Date, DUdf)
names(DUdf)[names(DUdf) == "PriceData$Date"] <- "Date"
```

<h5>Trigger Indices</h5>

The following 2 functions create one list of lists respectively that captures when the drawdowns and drawups exceed the trigger value defined above. 

The function consists of a while loop that returns the index (i.e. row number) of all the values within the column that exceed the trigger (-0.15 for drawdowns and 0.15 for drawups). An if statement if used to allow the while loop to continue ignoring any NA values

```{r}
trigIndexDD <- lapply(DDdf[-1], function(i){
  trigDD <- vector(mode = "integer", length = 1)
  l = length(i)
  s = 0
  pos = 1
  while(s <= l){
    x = which(i[(s+1):l] <= triggerDD)[1]+s
    if(is.na(x)){
      break
    } else{
      trigDD[pos] = x
    }
    s = trigDD[pos] + window
    pos = pos + 1
  }
  return(trigDD)
})

trigIndexDU <- lapply(DUdf[-1], function(i){
  trigDU <- vector(mode = "integer", length = 1)
  l = length(i)
  s = 0
  pos = 1
  while(s <= l){
    x = which(i[(s+1):l] >= triggerDU)[1]+s
    if(is.na(x)){
      break
    } else{
      trigDU[pos] = x
    }
    s = trigDU[pos] + window
    pos = pos + 1
  }
  return(trigDU)
})


print(trigIndexDD[1:5])
```

We now unlist the results and create a transposed dataframe that will allow us to calculate the cumluative return and thus conclude the profitability of short run reversal trading.

The transposed dataframe contains a column for each index calculated above for each share. For example, share ABG returns 6 row numbers when the trigIndexDD function is passed. After the transposition of the rows, there are 6 columns named ABG1, ABG2 ... ABG6, for each index value. This will allow for the calculation of the cumulative returns for each triggered event.


```{r}
ultrigDD <- unlist(trigIndexDD)
ultrigDD <- as.data.frame(t(ultrigDD))

print(ultrigDD[1:10])
```